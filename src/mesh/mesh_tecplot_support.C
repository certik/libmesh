// $Id: mesh_tecplot_support.C,v 1.12 2003-03-11 04:35:19 ddreyer Exp $

// The Next Great Finite Element Library.
// Copyright (C) 2002  Benjamin S. Kirk, John W. Peterson
  
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
  
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
  
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA



// C++ includes
#include <fstream>

// Local includes
#include "equation_systems_base.h"
#include "mesh_base.h"
#include "elem.h"

#ifdef HAVE_TECPLOT_API
namespace tecio {
  extern "C" {
# include <TECIO.h>
  }
}
#endif



void MeshBase::write_tecplot (const std::string& name,
			      EquationSystemsBase& es)
{
// #ifdef USE_COMPLEX_NUMBERS

//   // open _two_ files
//   std::ofstream out_Real(complex_filename(name, 0));
//   std::ofstream out_imag(complex_filename(name, 1));;

//   // get data
//   std::vector<Number> soln;
//   std::vector<std::string> names;
//   es.build_variable_names  (names);
//   es.build_solution_vector (soln);

//   // buffer for writing separately
//   std::vector<Real> Real_soln;
//   std::vector<Real> imag_soln;

//   prepare_complex_data(&soln, &Real_soln, &imag_soln);

//   if (processor_id() == 0)
//     {
//       write_tecplot (out_Real, &Real_soln, &names);
//       write_tecplot (out_imag, &imag_soln, &names);
//     }

// #else

  std::ofstream out(name.c_str());

  write_tecplot (out, es);

//#endif
}



void MeshBase::write_tecplot (std::ostream& out,
			      EquationSystemsBase& es)
{
  std::vector<Number> soln;
  std::vector<std::string> names;
  
  es.build_variable_names  (names);
  es.build_solution_vector (soln);

// #ifdef USE_COMPLEX_NUMBERS

//   // buffer for writing separately
//   std::vector<Real> Real_soln;
//   std::vector<Real> imag_soln;

//   prepare_complex_data(&soln, &Real_soln, &imag_soln);

//   if (processor_id() == 0)
//     {
//       std::cout << "Warning: save only Real part." << std::endl;
//       write_tecplot (out, &Real_soln, &names);
//     }

// #else

  if (processor_id() == 0)
    write_tecplot (out, &soln, &names);

//#endif
}



void MeshBase::write_tecplot (const std::string& name,
			      const std::vector<Number>* v,
			      const std::vector<std::string>* solution_names)
{
// #ifdef USE_COMPLEX_NUMBERS

//   if (v != NULL)
//     {
//       // open _two_ files
//       std::ofstream out_Real(complex_filename(name, 0));
//       std::ofstream out_imag(complex_filename(name, 1));;

//       // buffer for writing separately
//       std::vector<Real> Real_soln;
//       std::vector<Real> imag_soln;

//       prepare_complex_data(v, &Real_soln, &imag_soln);

//       if (processor_id() == 0)
// 	{
// 	  write_tecplot (out_Real, &Real_soln, solution_names);
// 	  write_tecplot (out_imag, &imag_soln, solution_names);
// 	}
//     }
//   else
//     {
//       // have no data, save only the mesh
//       std::ofstream out(name.c_str());
//       write_tecplot (out);  
//     }

// #else

  std::ofstream out(name.c_str());

  write_tecplot (out, v, solution_names);

//#endif
}




void MeshBase::write_tecplot (std::ostream& out,
			      const std::vector<Number>* v,
			      const std::vector<std::string>* solution_names)
{
  assert (out.good());

  // Write header to stream
  {
    {
      out << "# This file was generated by:" << std::endl
	  << "#" << std::endl
	  << "# $Id: mesh_tecplot_support.C,v 1.12 2003-03-11 04:35:19 ddreyer Exp $" << std::endl
	  << "#" << std::endl
	  << "# For a description of the Tecplot format see the Tecplot User's guide."
	  << std::endl
	  << "#" << std::endl;
    }

    out << "Variables=x,y,z";

    if (solution_names != NULL)
      for (unsigned int n=0; n<solution_names->size(); n++)
	{
#ifdef USE_REAL_NUMBERS
	  
	  // Write variable names for real variables
	  out << "," << (*solution_names)[n];

#else
	  
	  // Write variable names for complex variables
	  out << "," << "r_"   << (*solution_names)[n]
	      << "," << "i_"   << (*solution_names)[n];
	  
#endif
	}

    out << std::endl;
    
    if (_dim != 1)
      {
	out << "Zone f=fepoint, n=" << n_nodes() << ", e=" << n_active_sub_elem();
	
	if (_dim == 2)
	  out << ", et=quadrilateral" << std::endl;
	else if (_dim == 3)
	  out << ", et=brick" << std::endl;
      }
  }

  for (unsigned int i=0; i<n_nodes(); i++)
    {
      // Print the point without a newline
      point(i).write_unformatted(out, false);

      if ((v != NULL) && (solution_names != NULL))
	{
	  const unsigned int n_vars = solution_names->size();


	  for (unsigned int c=0; c<n_vars; c++)
	    {
#ifdef USE_REAL_NUMBERS	      
	      // Write real data
	      out << (*v)[i*n_vars + c] << " ";

#else
	      // Write complex data
	      out << (*v)[i*n_vars + c].real() << " "
		  << (*v)[i*n_vars + c].imag() << " ";

#endif
	    }
	  
	  out << std::endl;
	}
    }

  const_active_elem_iterator       it (elements_begin());
  const const_active_elem_iterator end(elements_end());

  for ( ; it != end; ++it)
    (*it)->write_tecplot_connectivity(out);
}



//--------------------------------------------------------
// Macros for handling Tecplot API data

#ifdef HAVE_TECPLOT_API

namespace
{
  class TecplotMacros
  {
  public:
    TecplotMacros(const unsigned int n_nodes,
		  const unsigned int n_vars,
		  const unsigned int n_cells,
		  const unsigned int n_vert);
    ~TecplotMacros();
    float & nd(const unsigned int i, const unsigned int j);
    int   & cd(const unsigned int i, const unsigned int j);
    std::vector<float> nodalData;
    std::vector<int>   connData;
    //float* nodalData;
    //int*   connData;
  private:
    const unsigned int n_nodes;
    const unsigned int n_vars;
    const unsigned int n_cells;
    const unsigned int n_vert;
  };
}



inline
TecplotMacros::TecplotMacros(const unsigned int nn,
			     const unsigned int nvar,
			     const unsigned int nc,
			     const unsigned int nvrt) :
  n_nodes(nn),
  n_vars(nvar),
  n_cells(nc),
  n_vert(nvrt)
{
  nodalData.resize(n_nodes*n_vars);
  connData.resize(n_cells*n_vert);
}



inline
TecplotMacros::~TecplotMacros()
{
}



inline
float & TecplotMacros::nd(const unsigned int i, const unsigned int j)
{
  return nodalData[(i)*(n_nodes) + (j)]; 
}



inline
int & TecplotMacros::cd(const unsigned int i, const unsigned int j)
{
  return connData[(i) + (j)*(n_vert)]; 
}

#endif
//--------------------------------------------------------




void MeshBase::write_tecplot_binary(const std::string& name,
				    EquationSystemsBase& es)
{
  std::vector<Number> soln;
  std::vector<std::string> names;
  
  es.build_variable_names  (names);
  es.build_solution_vector (soln);
  
  if (processor_id() == 0)
    write_tecplot_binary (name, &soln, &names);
}




// void MeshBase::write_tecplot_binary(const std::string& name,
// 				    const std::vector<Number>* vec,
// 				    const std::vector<std::string>* solution_names)
// {
// #ifdef USE_COMPLEX_NUMBERS

//   if (vec != NULL)
//     {
//       std::string buf;

//       // buffer for writing separately
//       std::vector<Real> Real_soln;
//       std::vector<Real> imag_soln;

//       prepare_complex_data(vec, &Real_soln, &imag_soln);

//       if (processor_id() == 0)
// 	{
// 	  buf = complex_filename(name, 0);
// 	  do_write_tecplot_binary (buf, &Real_soln, solution_names);
// 	  buf = complex_filename(name, 1);
// 	  do_write_tecplot_binary (buf, &imag_soln, solution_names);
// 	}
//     }
//   else
//     {
//       do_write_tecplot_binary (name);
//     }

// #else

//   do_write_tecplot_binary(name, vec, solution_names);

// #endif
//}



void MeshBase::write_tecplot_binary(const std::string& name,
				    const std::vector<Number>* vec,
				    const std::vector<std::string>* solution_names)
{
  // Call the ASCII output function if configure did not detect
  // the Tecplot binary API
#ifndef HAVE_TECPLOT_API
  
  {
    std::cerr << "WARNING: Tecplot Binary files require the Tecplot API." << std::endl
	      << "Continuing with ASCII output." << std::endl;
    
    std::ofstream out (name.c_str());
    write_tecplot(out, vec, solution_names);

    return;
  }
  
#else
  
  // Tecplot binary output only good for dim=2,3
  if (_dim == 1)
    {
      std::ofstream out (name.c_str());
      write_tecplot(out, vec, solution_names);

      return;
    }

  // Required variables
  std::string tecplot_variable_names;
  int is_double =  0,
    tec_debug =  0,
    cell_type = ((_dim==2) ? (1) : (3));

  // Build a string containing all the variable names to pass to Tecplot
  {
    tecplot_variable_names += "x, y, z";
    
    if (solution_names != NULL)
      {
	for (unsigned int name=0; name<solution_names->size(); name++)
	  {
#ifdef USE_REAL_NUMBERS

	    tecplot_variable_names += ", ";
	    tecplot_variable_names += (*solution_names)[name];

#else
	    
	    tecplot_variable_names += ", ";
	    tecplot_variable_names += "r_";
	    tecplot_variable_names += (*solution_names)[name];
	    tecplot_variable_names += ", ";
	    tecplot_variable_names += "i_";
	    tecplot_variable_names += (*solution_names)[name];

#endif
	  }
      }
  }

  // Instantiate a TecplotMacros interface.  In 2D the most nodes per
  // face should be 4, in 3D it's 8.

  
  TecplotMacros tm(n_nodes(),
#ifdef USE_REAL_NUMBERS		   
		   (3 + ((solution_names == NULL) ? 0 : solution_names->size())),
#else
		   (3 + 2*((solution_names == NULL) ? 0 : solution_names->size())),
#endif
		   n_active_sub_elem(),
		   ((_dim==2) ? 4 : 8)
		   );


  // Copy the nodes and data to the TecplotMacros class. Note that we store
  // everything as a float here since the eye doesn't require a double to
  // understand what is going on
  for (unsigned int v=0; v<n_nodes(); v++)
    {
      tm.nd(0,v) = static_cast<float>(point(v)(0));
      tm.nd(1,v) = static_cast<float>(point(v)(1));
      tm.nd(2,v) = static_cast<float>(point(v)(2));

      if ((vec != NULL) &&
	  (solution_names != NULL))
	{
	  const unsigned int n_vars = solution_names->size(); 

	  for (unsigned int c=0; c<n_vars; c++)
	    {
#ifdef USE_REAL_NUMBERS
	      
	      tm.nd((3+c),v) = static_cast<float>((*vec)[v*n_vars + c]);
#else
	      tm.nd((3+2*c),v)   = static_cast<float>((*vec)[v*n_vars + c].real());
	      tm.nd((3+2*c+1),v) = static_cast<float>((*vec)[v*n_vars + c].imag());
#endif
	    }
	}
    }


  // Copy the connectivity
  {   
    unsigned int te = 0;

    const_active_elem_iterator       it (elements_begin());
    const const_active_elem_iterator end(elements_end());

    for ( ; it != end; ++it)
      for (unsigned int se=0; se<(*it)->n_sub_elem(); se++)
	{
	  const std::vector<unsigned int> connectivity = (*it)->tecplot_connectivity(se);
	  
	  for (unsigned int node=0; node<connectivity.size(); node++)
	    tm.cd(node,te) = connectivity[node];
	  
	  te++;
	}
  }
  
  
  // Ready to call the Tecplot API
  {
    int ierr = 0,
      num_nodes = static_cast<int>(n_nodes()),
      num_cells = static_cast<int>(n_active_sub_elem());
    
    
    ierr = tecio::TECINI (NULL,
			  (char*) tecplot_variable_names.c_str(),
			  (char*) name.c_str(),
			  (char*) ".",
			  &tec_debug,
			  &is_double);
    
    assert (ierr == 0);
    
    ierr = tecio::TECZNE (NULL,
			  &num_nodes,
			  &num_cells,
			  &cell_type,
			  (char*) "FEBLOCK",
			  NULL);
    
    assert (ierr == 0);

    
    int total =
#ifdef USE_REAL_NUMBERS
      ((3 + ((solution_names == NULL) ? 0 : solution_names->size()))*num_nodes);
#else  
      ((3 + 2*((solution_names == NULL) ? 0 : solution_names->size()))*num_nodes);
#endif

    
    ierr = tecio::TECDAT (&total,
			  &tm.nodalData[0],
			  &is_double);
    
    assert (ierr == 0);
    
    ierr = tecio::TECNOD (&tm.connData[0]);
    
    assert (ierr == 0);
    
    ierr = tecio::TECEND ();
    
    assert (ierr == 0);
  }
      
#endif // #ifdef HAVE_TECPLOT_API
  
}

